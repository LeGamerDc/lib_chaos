## sparse set

***背景***：

游戏服务器存储大量同类对象，需要数据结构提供分配、访问、销毁功能。根据开发经验，抽象该数据结构的接口为：

1. `Place() -> (id, *T)` : 分配一个内存位置，给出唯一标志id。
2. `Get(id) -> *T` : 使用唯一id访问到对象。
3. `Remove(id)`: 回收id占用的内存位置。

考虑到性能，对该数据提出以下需求：

1. 内存连续紧凑存放。避免零星分配带来的gc压力，同时提高分配销毁（记号销毁）效率。
2. O(1) 操作。分配、销毁、访问都能O(1)操作，避免使用hash访问。
   在游戏开发中，有2种存储引用方式，1. 存储对象的 id， 2. 存储对象的指针。存储对象id的方式可以更好地控制引用的生命周期，因为只有一个地方维护了对象的指针；存储对象指针的方式使得对象生命周期管理复杂，因为对象存在着多个引用，但是访问效率更高。如果我们能O(1)访问对象，那么使用存储对象id方案更优。
3. 动态分配内存块。使用数组存储对象有一个很大的问题，即无法合理地提前预估分配内存大小，所以数据结构需要按需分配内存块

***思路***：

1. 假如直接分配一个 `array` 来存存放对象，并使用数组下标 `index` 作为对象id。
   *获得：* 快速分配，O(1)访问
   *问题：* 引用失效问题，其他位置可能存放了对象的引用id，当对象被回收后 `array` 同位置被分配后无法辨别引用的是否还是同一个对象。
2. 将 id 分为2个部分，数组下标 `index`部分和`tick`时间，查找对象时使用 id.index 查找位置，使用 id.tick 判定对象是否是引用的那个。
   *获得：* 解决引用失效问题
   *问题：* 程序需要一次性分配可能的最大对象数长度的内存，否则需要进行数组重分配+拷贝
3. 使用2层数据结构模型，1层使用固定长度的内存块分配对象（如8KB），2层维护内存块的占用情况，分配时先找到可用的2层内存块，再在一层内存块中分配内存。

***细节：***

1. 为了方便开发通过 id 辨别出对象的类型(如建筑，单位，怪物)，id 中额外嵌入一个 tag
2. 1层数据块中使用 next 字段维护了一个可用槽位的链表，可用O(1)找到空闲位置
3. 2层数据块参考go源码使用bit算法快速找到空闲块

***how to use:***

```go
type Unit struct {
	Attack  int32
	Defence int32
	...
}

var ss = MakeSparseArray[Unit](300) // 300： 每个内存块最大存储对象数
id, unit1 := ss.Place(113213, 1) // 113213: tick check, 1: type unit
unit2 := ss.Get(id)
assert(unit1 == unit2)
ss.Remove(id)
assert(ss.Get(id) == nil)

```

